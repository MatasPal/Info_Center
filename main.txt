package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"
)

// Message structure
type Message struct {
	ID   int
	Data string
}

// Topic structure and global topic map
type Topic struct {
	Name     string
	Messages []Message
	Clients  map[http.ResponseWriter]chan Message
	mu       sync.RWMutex
}

var topics = make(map[string]*Topic)
var messageID int
var mu sync.Mutex

// Initializes the HTTP server and defines the root handler.
func main() {
	// Set up HTTP handlers
	http.HandleFunc("/", homeHandler)
	http.HandleFunc("/infocenter/", handleRequests)

	log.Println("Starting server on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

// Handles root "/"
func homeHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	fmt.Fprintf(w, "Welcome to the InfoCenter!")
}

// Handles "/infocenter/{topic}" requests
func handleRequests(w http.ResponseWriter, r *http.Request) {
	if !strings.HasPrefix(r.URL.Path, "/infocenter/") {
		http.NotFound(w, r)
		return
	}

	topicName := r.URL.Path[len("/infocenter/"):]
	if topicName == "" {
		http.Error(w, "Topic not found", http.StatusNotFound)
		return
	}

	switch r.Method {
	case http.MethodPost:
		handlePost(w, r, topicName)
	case http.MethodGet:
		handleGet(w, r, topicName)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// Handles posting a message to a topic
func handlePost(w http.ResponseWriter, r *http.Request, topicName string) {
	msgData, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Failed to read request body", http.StatusInternalServerError)
		return
	}
	r.Body.Close()

	mu.Lock()
	messageID++
	msg := Message{ID: messageID, Data: string(msgData)}
	mu.Unlock()

	log.Printf("Message received: %s", msg.Data)

	topic := getTopic(topicName)
	topic.mu.Lock()
	topic.Messages = append(topic.Messages, msg)

	for client, ch := range topic.Clients {
		select {
		case ch <- msg:
			log.Printf("Message sent to client: %s", msg.Data)
		default:
			close(ch)
			delete(topic.Clients, client)
			log.Printf("Client disconnected")
		}
	}
	topic.mu.Unlock()

	w.WriteHeader(http.StatusNoContent)
}

// Handles getting messages from a topic and sending to clients
func handleGet(w http.ResponseWriter, r *http.Request, topicName string) {
	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming unsupported!", http.StatusInternalServerError)
		return
	}

	topic := getTopic(topicName)
	ch := make(chan Message)
	topic.mu.Lock()
	topic.Clients[w] = ch

	for _, msg := range topic.Messages {
		fmt.Fprintf(w, "id: %d\nevent: msg\ndata: %s\n\n", msg.ID, msg.Data)
		flusher.Flush()
	}
	topic.mu.Unlock()

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	timeout := time.After(30 * time.Second)
	start := time.Now()

	log.Printf("Client subscribed to topic: %s", topicName)

	for {
		select {
		case msg := <-ch:
			log.Printf("Sending message to client: %s", msg.Data)
			fmt.Fprintf(w, "id: %d\nevent: msg\ndata: %s\n\n", msg.ID, msg.Data)
			flusher.Flush()
		case <-timeout:
			duration := time.Since(start)
			log.Printf("Client disconnected after %d seconds", int(duration.Seconds()))
			fmt.Fprintf(w, "event: timeout\ndata: %ds\n\n", int(duration.Seconds()))
			flusher.Flush()
			topic.mu.Lock()
			delete(topic.Clients, w)
			topic.mu.Unlock()
			removeTopicIfEmpty(topicName)
			return
		}
	}
}

// Retrieves or creates a topic
func getTopic(name string) *Topic {
	mu.Lock()
	defer mu.Unlock()

	if topic, exists := topics[name]; exists {
		return topic
	}

	newTopic := &Topic{
		Name:    name,
		Clients: make(map[http.ResponseWriter]chan Message),
	}
	topics[name] = newTopic
	return newTopic
}

// Removes a topic if no clients are left
func removeTopicIfEmpty(topicName string) {
	mu.Lock()
	defer mu.Unlock()

	topic, exists := topics[topicName]
	if exists && len(topic.Clients) == 0 {
		delete(topics, topicName)
		log.Printf("Topic %s removed due to inactivity", topicName)
	}
}
